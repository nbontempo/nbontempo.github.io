<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="renderer" content="webkit">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  
  <title>Processing Pipelines (Dataflow) - Introduction - Nicolas Bontempo</title>
  
  <meta name="description" content="Hello Guys, recently I changed a job going to a new challenge into Take. From this, I&rsquo;m studying parts of the stack which Dataflow is a big part. This is the start of my summary mostly provided by the study of the documentation and some coding.
Processing Pipelines (Dataflow) - Introduction The library Dataflow provides several functions to intensive processing. When you develop some logic using the concept of pipelines, basically you are creating steps of processing called blocks.">
  <meta name="author" content="Nicolas Bontempo">
  
  <link href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700,700i" rel="stylesheet">
  <link href="https://cdn.bootcss.com/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet">
  <link href="/css/style.css" rel="stylesheet">
  
  <link rel="apple-touch-icon" href="/img/apple-touch-icon.png">
  <link rel="icon" href="/img/favicon.ico">
  
  <meta name="generator" content="Hugo 0.45">
  
  <link rel="alternate" type="application/atom+xml" href="/index.xml" title="Nicolas Bontempo">
</head>
<body class="single">
  <header class="header">
    
    <p class="title"><a href="/"><span>üê±‚Äçüëì</span>Nicolas Bontempo</a></p>
    
    <button class="menu-toggle" type="button"></button>
    <nav class="menu">
      <ul>
        
        
        <li class="">
          <a href="https://github.com/nickbom">Github</a>
        </li>
        
        <li class="">
          <a href="https://www.linkedin.com/in/nicolasbontempo">Linkedin</a>
        </li>
        
        <li class="">
          <a href="/sobre/">Sobre o autor</a>
        </li>
        
      </ul>
    </nav>
  </header>
  <main class="main">

<article class="post post-view">
  <header class="post-header">
    <h1 class="post-title">Processing Pipelines (Dataflow) - Introduction</h1>
    <p class="post-meta">Nicolas Bontempo ¬∑ 09/09/2018<div style="color:grey; font-size:16px;">
        <strong>Tags:</strong> 
        <a href="/%20/tags/%20dataflow">dataflow</a> 
        <a href="/%20/tags/%20pipeline">pipeline</a> 
      </div>
    </p>
  </header>
  <div class="post-content">

<p>Hello Guys, recently I changed a job going to a new challenge into <a href="https://take.net/">Take</a>. From this, I&rsquo;m studying parts of the stack which Dataflow is a big part. This is the start of my summary mostly provided by the study of the documentation and some coding.</p>

<h1 id="processing-pipelines-dataflow-introduction">Processing Pipelines (Dataflow) - Introduction</h1>

<p>The library Dataflow provides several functions to intensive processing. When you develop some logic using the concept of pipelines, basically you are creating steps of processing called blocks.</p>

<p>The library Dataflow is available like one <a href="https://www.nuget.org/packages/Microsoft.Tpl.Dataflow">package NUGET</a>. It abstracts away most of the work needed when creating asynchronous and parallel processing code.</p>

<h2 id="types-of-blocks-on-dataflow">Types of blocks on Dataflow</h2>

<p>The library Dataflow structures it in one concept called Blocks, which are data structures that buffer and process data. There are three types of a block on Dataflow: <code>Source Blocks</code> source of data and can be read, <code>Target Blocks</code> receiver of data and can be written and <code>Propagator Blocks</code> that is both source and target.</p>

<p>This blocks can be connected forming one pipeline, which is a form of network, in that way data can be processed through the pipe propagating asynchronously to targets as that data becomes available. The method <code>LinkTo</code> presented on the source blocks and propagator, links the blocks, with this, you can connect to one or more targets, and provide a filter for each link (optional). This is useful for example you want just the items who has value to continue on the pipeline.</p>

<p>These types are divided into three categories: <em>buffering blocks</em>, <em>execution blocks</em> and <em>grouping blocks</em>.</p>

<h3 id="buffering-blocks">Buffering Blocks</h3>

<p>Can be used to hold data. There are three blocks of this category: <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.bufferblock-1">BufferBlock<T></a>,  <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.broadcastblock-1">BroadcastBlock<T></a> and <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.writeonceblock-1">WriteOnceBlock<T></a>.</p>

<h4 id="bufferblock-t">BufferBlock<T></h4>

<p>This block store a queue of messages that can be written to by multiple sources and read by multiple targets. When a target receives a message from this block, that message is removed from the queue. In that way, each message only can be read by a single target. The use case for the BufferBlock is when you want to pass multiple messages to another part of the software and it must receive each message.</p>

<h4 id="broadcastblock-t">BroadcastBlock<T></h4>

<p>The use case for the BroadcastBlock is when you want to pass multiple messages to another part of the software, but it needs only the most recent value and when you want to broadcast a message to multiple components.</p>

<h4 id="writeonceblock-t">WriteOnceBlock<T></h4>

<p>This block becomes immutable after it receives a value, and when one target receives a message from this block, that message is not removed from that object, sending a message to multiple targets. Therefore after the block receives a message, it discards subsequent messages. The use case for the WriteOnceBlock is when you want to propagate only the first of multiple messages.</p>

<h3 id="configuring-the-buffering-blocks">Configuring the Buffering Blocks</h3>

<p>Providing a <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.dataflowblockoptions">DataflowBlockOptions</a> to the constructor of the blocks can configure some behavior on your pipeline.</p>

<ul>
<li>BoundedCapacity - The maximum number of messages that can be buffered by the block</li>
<li>EnsureOrdered - No need to explain</li>
<li>MaxMessagesPerTask - The maximum number of messages that can be processed per task</li>
<li>NameFormat - The format string to use when a block is queried for its name</li>
<li>TaskScheduler - <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.taskscheduler?view=netcore-2.1">TaskScheduler</a> to use for scheduling tasks.</li>
<li>CancellationToken - monitor cancellation requests</li>
</ul>

<h3 id="execution-blocks">Execution Blocks</h3>

<p>Can be used to execute a delegate user-provided for each received data. In all execution blocks, he receives a delegate and the processing of each input element is considered completed when the delegate returns. There are three blocks of this category: <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.actionblock-1">ActionBlock<T></a>, <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.transformblock-2">TransformBlock<T></a> and <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.transformmanyblock-2">TransformManyBlock<T></a></p>

<h4 id="actionblock-t">ActionBlock<T></h4>

<p>The ActionBlock is a target block that executes a delegate when it receives data. This can be used for synchronous and asynchronous processing of each message. After this, you wait until the block processing is completed. Basically, he will start a buffer of items, start the task to sequentially or parallelly process (can be configured) and complete the task when the buffer is empty.
The use case for the ActionBlock is when you want to process messages.</p>

<h4 id="transformblock-t">TransformBlock<T></h4>

<p>This is the block that I most use, both source and target (propagator block) because you can simply create him, configure what he needs to do, starting posting inside him and returning the <code>TOutput</code> to the following block.</p>

<h4 id="transformmanyblock-t">TransformManyBlock<T></h4>

<p>This block resembles the TransformBlock, the only is change is that he produces zero or more output values for each input.</p>

<h3 id="configuring-the-execution-blocks">Configuring the Execution Blocks</h3>

<p>Providing an <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.executiondataflowblockoptions?view=netcore-2.1">ExecutionDataflowBlockOptions</a> to the constructor of the execution blocks who inherits DataflowBlockOptions. Providing two more options for configuration:</p>

<ul>
<li>MaxDegreeOfParallelism - The maximum number of messages that may be processed per task. Per default is 1, when the value is higher than 1 the messages will be processed concurrently.</li>
<li>SingleProducerConstrained    - Get if the code is constrained to one producer at a time</li>
</ul>

<h3 id="grouping-blocks">Grouping Blocks</h3>

<p>There are three blocks of this category:  <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.batchblock-1">BatchBlock<T></a>, <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.joinblock-2">JoinBlock<T1,T2></a>, and <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.batchedjoinblock-2">BatchedJoinBlock<T1,T2></a>. There is two modes for grouping blocks, <code>Greedy</code> and <code>NonGreedy</code>, the greedy mode is default when he receives the specified number of elements he return the array, the non greedy mode postpones messages until enough sources offer messages to the block to form a batch.</p>

<h4 id="batchblock-t">BatchBlock<T></h4>

<p>This block combines sets of input data, known as batches, into arrays of output data. When received one specific number of elements, it propagates an array that contains those elements.</p>

<h4 id="joinblock-t1-t2">JoinBlock<T1, T2...></h4>

<p>This block collects input element and propagates Tuple with the types defined <code>Tuple&lt;T1, T2...&gt;</code>.</p>

<h4 id="batchedjoinblock-t1-t2">BatchedJoinBlock<T1, T2...></h4>

<p>This block collect batched of input elements and propagate Tuples with the lists of the types defined <code>Tuple&lt;IList&lt;T1&gt;, IList&lt;T2&gt;...&gt;</code>.</p>

<h3 id="configuring-the-grouping-blocks">Configuring the Grouping Blocks</h3>

<p>Providing a <a href="https://docs.microsoft.com/pt-br/dotnet/api/system.threading.tasks.dataflow.groupingdataflowblockoptions?view=netcore-2.1">GroupingDataflowBlockOptions</a> to the constructor of the execution blocks who inherits DataflowBlockOptions. Providing two more options for configuration:</p>

<ul>
<li>Greedy - Boolean value to use to determine whether to greedily consume offered messages.</li>
<li>MaxNumberOfGroups - The maximum number of groups that should be generated by the block.</li>
</ul>

<h2 id="starting-the-pipeline">Starting the pipeline</h2>

<p>The idea behind the pipeline is to parts of a software communicate with each other, by the act of sending messages. This can be started by an act of sending to target dataflow blocks messages with <code>Post</code> or <code>SendAsync</code> and to receive a message from source blocks <code>Receive</code>, <code>ReceiveAsync</code> and <code>TryReceive</code>.</p>

<p>In the next post let&rsquo;s get our hands dirty and create some pipeline code.</p>
</div>
  <footer class="post-footer">
    
    <ul class="post-tags">
      
      <li>
        <a href="/tags/dataflow/">dataflow</a>
      </li>
      
      <li>
        <a href="/tags/pipeline/">pipeline</a>
      </li>
      
    </ul>
    
  </footer>
  
   
  <div id="disqus_thread"></div>
  <script>
    var disqus_shortname = 'nicolasbontempo';
    (function () { 
      var d = document,
        s = d.createElement('script');
      s.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
  <noscript>
    Please enable JavaScript to view the
    <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
   
</article>
</main>
<footer class="footer">
  <span>&copy; 2015-2019 Nicolas Bontempo üéâ</span>
</footer>
<script src="https://cdn.bootcss.com/instantclick/3.0.1/instantclick.min.js" data-no-instant></script>
<script data-no-instant>InstantClick.init();</script>
<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js" data-no-instant></script>

<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-71553462-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

<script data-no-instant>
  hljs.initHighlightingOnLoad();
  menuToggle();
  InstantClick.on('change', function() {
    var blocks = document.querySelectorAll('pre code');
    for (var i = 0; i < blocks.length; i++) {
      hljs.highlightBlock(blocks[i]);
    }
    menuToggle();
  });
  function menuToggle() {
    var $toggle = document.querySelector('.menu-toggle');
    if (!$toggle.offsetParent) {
      return;
    }
    var $body = document.querySelector('body');
    $toggle.addEventListener('click', function() {
      $body.classList.toggle('noscroll');
    }, false);
  }
</script>
</body>
</html>
